<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Rust引用、可变引用及其编译错误解析</title>
      <link href="/2021/06/14/rust-ref/"/>
      <url>/2021/06/14/rust-ref/</url>
      
        <content type="html"><![CDATA[<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p><a href="http://xiaosong.fun/2021/05/30/rust-owner-compile/" target="_blank" rel="noopener">上节</a>中提到，Rust中，无Copy Trait的数据类型的函数传参，等效于所有权的转移。因此当函数退出时，接收所有权的变量作用域结束，数据就被销毁。那么，是否有办法让函数传参不发生所有权的转移？</p><p>有的！</p><p>Rust提供了被称为“引用”的机制。如下例：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line">    <span class="keyword">let</span> len = calculate_length(&amp;s1);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"The length of '&#123;&#125;' is &#123;&#125;."</span>, s1, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">calculate_length</span></span>(s: &amp;<span class="built_in">String</span>) -&gt; <span class="built_in">usize</span> &#123;</span><br><span class="line">    s.len()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序可以被正常运行，变量<code>s</code>不会在离开自己的作用域时销毁其指向的数据，因为它并不拥有数据的所有权。</p><h4 id="引用的常见编译错误"><a href="#引用的常见编译错误" class="headerlink" title="引用的常见编译错误"></a>引用的常见编译错误</h4><h5 id="错误1"><a href="#错误1" class="headerlink" title="错误1"></a>错误1</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> s = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line">    append_string(&amp;s);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">append_string</span></span>(s: &amp;<span class="built_in">String</span>) &#123;</span><br><span class="line">    s.push_str(<span class="string">" world"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cargo build</span></span><br><span class="line">   Compiling hello v0.1.0 (/home/spencer/share/my_code/rust_prj/hello)</span><br><span class="line">error[E0596]: cannot borrow `*s` as mutable, as it is behind a `&amp;` reference</span><br><span class="line"><span class="meta">  --&gt;</span><span class="bash"> src/main.rs:14:5</span></span><br><span class="line">   |</span><br><span class="line">13 | fn append_string(s: &amp;String) &#123;</span><br><span class="line">   |                     ------- help: consider changing this to be a mutable reference: `&amp;mut String`</span><br><span class="line">14 |     s.push_str(" world");</span><br><span class="line">   |     ^ `s` is a `&amp;` reference, so the data it refers to cannot be borrowed as mutable</span><br></pre></td></tr></table></figure><p><strong>解析</strong>：引用是默认是可变的，修改引用变量指向的数据是被禁止的。</p><h3 id="可变引用"><a href="#可变引用" class="headerlink" title="可变引用"></a>可变引用</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>Rust允许我们使用<code>mut</code>将某个引用声明为“可变引用”</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line">    append_string(&amp;<span class="keyword">mut</span> s);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">append_string</span></span>(some_string: &amp;<span class="keyword">mut</span> <span class="built_in">String</span>) &#123;</span><br><span class="line">    some_string.push_str(<span class="string">", world"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序可以被正常执行，<code>append_string</code>函数的入参类型被指定为<code>&amp;mut String</code>，即可变引用的String类型。<code>append_string</code>中完成了对入参的修改。</p><p>Rust以数据访问安全著称。那么它是如何在支持可变引用的情况下，仍然可以避免数据的竞争的？大家可以通过以下编译错误的例子体会一下。</p><h4 id="可变引用常见的编译错误"><a href="#可变引用常见的编译错误" class="headerlink" title="可变引用常见的编译错误"></a>可变引用常见的编译错误</h4><h5 id="错误2"><a href="#错误2" class="headerlink" title="错误2"></a>错误2</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line">    <span class="keyword">let</span> r1 = &amp;<span class="keyword">mut</span> s;</span><br><span class="line">    <span class="keyword">let</span> r2 = &amp;<span class="keyword">mut</span> s;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;, &#123;&#125;"</span>, r1, r2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译结果 ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">   Compiling hello v0.1.0 (/home/spencer/share/my_code/rust_prj/hello)</span><br><span class="line">error[E0499]: cannot borrow `s` as mutable more than once at a time</span><br><span class="line"><span class="meta"> --&gt;</span><span class="bash"> src/main.rs:5:14</span></span><br><span class="line">  |</span><br><span class="line">4 |     let r1 = &amp;mut s;</span><br><span class="line">  |              ------ first mutable borrow occurs here</span><br><span class="line">5 |     let r2 = &amp;mut s;</span><br><span class="line">  |              ^^^^^^ second mutable borrow occurs here</span><br><span class="line">6 | </span><br><span class="line">7 |     println!("&#123;&#125;, &#123;&#125;", r1, r2);</span><br><span class="line">  |                        -- first borrow later used here</span><br></pre></td></tr></table></figure><p><strong>解析</strong>：以上例子中，r1和r2都为s的可变引用，且在同一个作用域中。Rust编译不不允许这样的代码存在。因为<code>r1</code>和<code>r2</code>可以在同一个作用域操作同一份数据，会产生数据竞争。</p><p>当我们用大括号将<code>r1</code>的作用域加以限制之后，<code>r1</code>和<code>r2</code>的作用域不再重叠，就可以编译通过了。如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> r1 = &amp;<span class="keyword">mut</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> r2 = &amp;<span class="keyword">mut</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="错误3"><a href="#错误3" class="headerlink" title="错误3"></a>错误3</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line">    <span class="keyword">let</span> r1 = &amp;<span class="keyword">mut</span> s;</span><br><span class="line">    s.push_str(<span class="string">" world"</span>);</span><br><span class="line">    r1.push_str(<span class="string">" hello2"</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译结果 ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">error[E0499]: cannot borrow `s` as mutable more than once at a time</span><br><span class="line"><span class="meta"> --&gt;</span><span class="bash"> src/main.rs:4:5</span></span><br><span class="line">  |</span><br><span class="line">3 |     let r1 = &amp;mut s;</span><br><span class="line">  |              ------ first mutable borrow occurs here</span><br><span class="line">4 |     s.push_str(" world");</span><br><span class="line">  |     ^ second mutable borrow occurs here</span><br><span class="line">5 |     r1.push_str(" hello2");</span><br><span class="line">  |     -- first borrow later used here</span><br></pre></td></tr></table></figure><p><strong>解析</strong>：与上一个错误类似，同样也出现了“second mutable borrow occurs here”的提示。而发生此错误的地方，是第4行使用原始变量<code>s</code>做了数据修改的操作。编译器将使用原始可变变量做的数据修改，视为另一种可变引用。于是，<code>s</code>和<code>r1</code>产生了数据竞争，编译失败。</p><p>更确切地说，Rust编译器在以下三个条件同时满足时，发出编译错误：</p><ul><li>两个或两个以上的可变引用指向同一份数据。</li><li>其中至少一个可变引用指会向空间写入数据。</li><li>没有同步数据的访问机制。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Rust </tag>
            
            <tag> 引用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust所有权编译错误解析</title>
      <link href="/2021/05/30/rust-owner-compile/"/>
      <url>/2021/05/30/rust-owner-compile/</url>
      
        <content type="html"><![CDATA[<h1 id="所有权"><a href="#所有权" class="headerlink" title="所有权"></a>所有权</h1><h5 id="Rust所有权三原则"><a href="#Rust所有权三原则" class="headerlink" title="Rust所有权三原则"></a>Rust所有权三原则</h5><ol><li>Each value in Rust has a variable that’s called its owner. （Rust中每一个变量都有一个所有者。）</li><li>There can only be one owner at a time.（在任一时刻，所有者有且仅有一个。）</li><li>When the owner goes out of scope, the value will be dropped.（当所有者离开其作用域后，它所拥有的数据会被释放。）</li></ol><h4 id="所有权相关编译错误"><a href="#所有权相关编译错误" class="headerlink" title="所有权相关编译错误"></a>所有权相关编译错误</h4><h5 id="错误1"><a href="#错误1" class="headerlink" title="错误1"></a>错误1</h5><p>代码段1：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = s1; </span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"&#123;&#125;, world!"</span>, s1);</span><br></pre></td></tr></table></figure><p>编译结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">   Compiling ownership v0.1.0 (file:///projects/ownership)</span><br><span class="line">error[E0382]: borrow of moved value: `s1`</span><br><span class="line"><span class="meta"> --&gt;</span><span class="bash"> src/main.rs:5:28</span></span><br><span class="line">  |</span><br><span class="line">2 |     let s1 = String::from("hello");</span><br><span class="line">  |         -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait</span><br><span class="line">3 |     let s2 = s1;</span><br><span class="line">  |              -- value moved here</span><br><span class="line">4 | </span><br><span class="line">5 |     println!("&#123;&#125;, world!", s1);</span><br><span class="line">  |                            ^^ value borrowed here after move</span><br><span class="line"></span><br><span class="line">error: aborting due to previous error</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0382`.</span><br><span class="line">error: could not compile `ownership`</span><br></pre></td></tr></table></figure><p><strong>解析</strong>：String的所有权从s1转移到s2后，不能再使用s1访问数据。否则违反原则2。</p><p>然而，对于下面这段代码，似乎产生了与代码段1矛盾的编译结果。</p><p>代码段2：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> u1:<span class="built_in">u32</span> = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">let</span> u2 = u1; </span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;, world!"</span>, u1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果按代码段1的逻辑，u2=u1时，数字20的所有权传移给u2，u1应该不能再被访问。然而这段代码可以被正确地编译，这是为什么呢？</p><p>原因是：针对u32类型的数据，rust赋予其Copy特性（trait）。凡是拥有Copy trait的数据类型，“=”都表示数据的复制而非传有权的转移。因此在u2=u1之后，u2和u1里，都保存有20这一整型数据。</p><p>以下数据类型有Copy trait：</p><ul><li>所有整型：u32 u64等</li><li>布尔型</li><li>所有浮点型：f32 f64等</li><li>字符型：char</li><li>元组（Tuples）：如果组成元组的每个成员都有Copy trait，那么此元组也有Copy trait。</li></ul><h5 id="错误2"><a href="#错误2" class="headerlink" title="错误2"></a>错误2</h5><p>代码段3</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line">    print_int(x);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, x);</span><br><span class="line">    <span class="keyword">let</span> s = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line">    print_string(s);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, s);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">print_string</span></span>(some_string: <span class="built_in">String</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, some_string);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">print_int</span></span>(some_integer: <span class="built_in">i32</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, some_integer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cargo build</span></span><br><span class="line">   Compiling hello v0.1.0 (/home/spencer/share/my_code/rust_prj/hello)</span><br><span class="line">error[E0382]: borrow of moved value: `s`</span><br><span class="line"><span class="meta"> --&gt;</span><span class="bash"> src/main.rs:9:20</span></span><br><span class="line">  |</span><br><span class="line">7 |     let s = String::from("hello");</span><br><span class="line">  |         - move occurs because `s` has type `String`, which does not implement the `Copy` trait</span><br><span class="line">8 |     print_string(s);</span><br><span class="line">  |                  - value moved here</span><br><span class="line">9 |     println!("&#123;&#125;", s);</span><br><span class="line">  |                    ^ value borrowed here after move</span><br><span class="line"></span><br><span class="line">error: aborting due to previous error</span><br></pre></td></tr></table></figure><p><strong>解析</strong>：函数的传参赋值，视作与“=”有相同的作用。即：变量<code>s</code>被传入<code>print_string</code>函数后，它的所有仅传移给<code>some_string</code>，又因为原则三：“当所有者离开其作用域后，它所拥有的数据会被释放。”<code>some_string</code>所拥有的字符串数据，在离开<code>print_string</code>之后，即被释放。因此第9行的<code>println!(&quot;{}&quot;, s);</code>对<code>s</code>的访问编译失败。<br>而对整型数据的传参，则不存在类似的问题。因为整型数据有Copy trait，传参意味着数据的复制，而不是所有权的转移。因此第4行<code>println!(&quot;{}&quot;, x);</code>并没有编译失败。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Rust </tag>
            
            <tag> Owner </tag>
            
            <tag> Compiling </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>强烈反对将&quot;.&quot;加入PATH环境变量中，为什么？</title>
      <link href="/2021/02/14/dot-append-to-path/"/>
      <url>/2021/02/14/dot-append-to-path/</url>
      
        <content type="html"><![CDATA[<p>Linux下常用的工具如ping，objdump，pwd等，如果需要使用，无论当前处于哪个目录，只需直接输入程序名即可，例如“ping 1.1.1.1”；而自己编写的”hello world”程序，必需加上”./“的前缀，例如：“./hello.elf”。这是为什么？</p><p>直接原因是，Linux系统是在PATH环境变量指定的路径中查找程序的。而ping，objdump，pwd等，都存放于/sbin/，/bin/，/usr/bin等目录，这些目录默认就在PATH环境变量中。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ echo $PATH</span><br><span class="line"><span class="regexp">/home/</span>spencer<span class="regexp">/.local/</span><span class="string">bin:</span><span class="regexp">/usr/</span>local<span class="regexp">/sbin:/</span>usr<span class="regexp">/local/</span><span class="string">bin:</span><span class="regexp">/usr/</span><span class="string">sbin:</span><span class="regexp">/usr/</span><span class="string">bin:</span><span class="regexp">/sbin:/</span><span class="string">bin:</span><span class="regexp">/usr/</span><span class="string">games:</span><span class="regexp">/usr/</span>local<span class="regexp">/games:/</span>snap/bin</span><br></pre></td></tr></table></figure><p>而在其它目录下的程序，就需要执行者手动指定程序路径，于是就有了上文所说的“./”前缀，这就是为了明确指定目录。</p><h3 id="“聪明的”小技巧？"><a href="#“聪明的”小技巧？" class="headerlink" title="“聪明的”小技巧？"></a>“聪明的”小技巧？</h3><p>为了不输入“./”，我们何不把当前目录”.”加入PATH变量？这样执行当前目录下的程序，就不需要输入”./“了。<br>我们先试试可不可行。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">spencer<span class="meta">@ubuntu</span>:~$ ls -l hello.sh </span><br><span class="line">-rwxrwxr-x <span class="number">1</span> spencer spencer <span class="number">20</span> Feb <span class="number">14</span> <span class="number">20</span>:<span class="number">24</span> hello.sh</span><br><span class="line">spencer<span class="meta">@ubuntu</span>:~$ hello.sh</span><br><span class="line">hello.<span class="string">sh:</span> command not found</span><br><span class="line">spencer<span class="meta">@ubuntu</span>:~$ export PATH=.:$PATH</span><br><span class="line">spencer<span class="meta">@ubuntu</span>:~$ echo $PATH</span><br><span class="line">.:<span class="regexp">/home/</span>spencer<span class="regexp">/.local/</span><span class="string">bin:</span><span class="regexp">/usr/</span>local<span class="regexp">/sbin:/</span>usr<span class="regexp">/local/</span><span class="string">bin:</span><span class="regexp">/usr/</span><span class="string">sbin:</span><span class="regexp">/usr/</span><span class="string">bin:</span><span class="regexp">/sbin:/</span><span class="string">bin:</span><span class="regexp">/usr/</span><span class="string">games:</span><span class="regexp">/usr/</span>local<span class="regexp">/games:/</span>snap/bin</span><br><span class="line">spencer<span class="meta">@ubuntu</span>:~$ hello.sh </span><br><span class="line">hello world</span><br></pre></td></tr></table></figure><p>在~目录下放了一个小程序hello.sh，直接输入hello.sh会提示错误，而把”.”加入PATH之后，输入hello.sh可以正常运行。</p><p>这样看起来，这招似乎可行？</p><h3 id="一个大漏洞"><a href="#一个大漏洞" class="headerlink" title="一个大漏洞"></a>一个大漏洞</h3><p>大家都知道，Linux给不同用户分配了不同的权限。/sbin/，/bin/等目录下的程序，通常只有root用户才有权限修改。</p><p>如果把“.”加入PATH，会出现什么问题？</p><p><strong>一个通用用户在当前目录中，创建一个与/sbin/，/bin/等目录下的同名程序，即可替代只有root帐户才有权限修改的程序的行为。从而实现越权。</strong></p><p>举个极端点的例子：在当前目录下，创建一个程序叫”cd”，里面的脚本是：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">rm</span> -rf <span class="variable">$1</span></span><br></pre></td></tr></table></figure><p>那么，在当前目录下，”cd”这条命令的行为，就被一个普通用户替换掉了，变成了删除参数指定的目录。这显然是个巨大的漏洞。</p><p>替换”cd”程序这种事，应该只有root才能做。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>不得不承认，Linux社区中集合了这个世界上最聪明的一群人。通过这样的设计，刻意的引导用户养成习惯，只有系统PATH的才能省略路径运行，自己目录下的就要指定路径。从而避免黑客通过在当前目录放置对应的同名程序从而让你主动运行了这些文件。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 安全漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么TCP是三次握手？而不是两次或四次？</title>
      <link href="/2020/11/05/three-handshake/"/>
      <url>/2020/11/05/three-handshake/</url>
      
        <content type="html"><![CDATA[<p>为什么TCP是三次握手？而不是两次或四次？</p><h2 id="TCP连接建立的条件"><a href="#TCP连接建立的条件" class="headerlink" title="TCP连接建立的条件"></a>TCP连接建立的条件</h2><p>我们这里从TCP连接建立的前提入手。TCP连接建立的前提，是通信的双方都要知道本方和对方的发送和接收功能，都是正常的。也就是在TCP连接建立之前，有以下八个待确认项。</p><table><thead><tr><th></th><th>服务端发送</th><th>服务端接收</th><th>客户端发送</th><th>客户端接收</th></tr></thead><tbody><tr><td>服务端</td><td>○</td><td>○</td><td>○</td><td>○</td></tr><tr><td>客户端</td><td>○</td><td>○</td><td>○</td><td>○</td></tr></tbody></table><p>图例：○：待确认，√：已确认</p><h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><h3 id="第一次握手"><a href="#第一次握手" class="headerlink" title="第一次握手"></a>第一次握手</h3><p>客户端向服务端发送连接请求报文段。该报文段的头部中SYN=1，ACK=0，seq=x。<br>服务端接收到报文后，可以确认客户端的发送功能，服务端的接收功能，都是正常的。</p><table><thead><tr><th></th><th>服务端发送</th><th>服务端接收</th><th>客户端发送</th><th>客户端接收</th></tr></thead><tbody><tr><td>服务端</td><td>○</td><td>√</td><td>√</td><td>○</td></tr><tr><td>客户端</td><td>○</td><td>○</td><td>○</td><td>○</td></tr></tbody></table><h3 id="第二次握手"><a href="#第二次握手" class="headerlink" title="第二次握手"></a>第二次握手</h3><p>服务端收到连接请求报文段后，如果同意连接，则会发送一个应答：SYN=1，ACK=1，seq=y，ack=x+1。<br>客户端接收到第二次握手报文后，可以确认服务端的发送功能，客户端的接收功能是正常的。不过，此时服务端并不知道自己的发送功能，客户端的接收功能是否正常。</p><table><thead><tr><th></th><th>服务端发送</th><th>服务端接收</th><th>客户端发送</th><th>客户端接收</th></tr></thead><tbody><tr><td>服务端</td><td>○</td><td>√</td><td>√</td><td>○</td></tr><tr><td>客户端</td><td>√</td><td>√</td><td>√</td><td>√</td></tr></tbody></table><h3 id="第三次握手"><a href="#第三次握手" class="headerlink" title="第三次握手"></a>第三次握手</h3><p>当客户端收到连接同意的应答后，还要向服务端发送一个确认报文段，表示：服务端发来的连接同意应答已经成功收到。该报文段的头部为：ACK=1，seq=x+1，ack=y+1<br>此时，服务端就可以确认自己的发送功能，客户端的接收功能是正常的。</p><table><thead><tr><th></th><th>服务端发送</th><th>服务端接收</th><th>客户端发送</th><th>客户端接收</th></tr></thead><tbody><tr><td>服务端</td><td>√</td><td>√</td><td>√</td><td>√</td></tr><tr><td>客户端</td><td>√</td><td>√</td><td>√</td><td>√</td></tr></tbody></table><p>至此，八个确认项都确认完成。服务端和客户端就可以开始愉快地通信了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 三次握手 </tag>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World!</title>
      <link href="/2020/10/18/hello-world/"/>
      <url>/2020/10/18/hello-world/</url>
      
        <content type="html"><![CDATA[<h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><p>家里迎来了新成员。真是很可爱。</p><p>但免不了的手忙脚乱，新手爸爸还不太会抱娃。</p><p>我最近的睡觉时间提前到了21:30，进入养生模式。就是为了每晚给娃留出2小时哭闹哄睡的时间。</p><h2 id="OneCmd"><a href="#OneCmd" class="headerlink" title="OneCmd"></a>OneCmd</h2><p>这个博客更新得少了，最近个人项目的重心转到另一个项目中。我估且把它称为OneCmd。</p><p>工作上本来就忙，现在又多了个娃，我估了一下进度（每周投入2~6小时）。OneCmd估计一年后才能上线。</p><p>随性吧，反正也是玩票。</p><h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><p>工作上，其实挺不如意的。</p><p>项目进度紧，其实这倒不是最难的，难的是向兄弟部门和领导解释我们的工作量。</p><p>为啥别人眼里的任务的工作量，和我们认为的任务的工作量，总是差距这么大。</p><h2 id="平安"><a href="#平安" class="headerlink" title="平安"></a>平安</h2><p>最后再回到孩子身上，当抱抱起柔软的它时，之前对它的种种抱负都消失不见了。</p><p>唯独希望你，平安喜乐。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 日记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何评估一个进程占用的内存空间</title>
      <link href="/2020/05/17/mem-analysis/"/>
      <url>/2020/05/17/mem-analysis/</url>
      
        <content type="html"><![CDATA[<p>Linux提供了非常丰富的手段，供我们来评估一个进程的内存占用。top，/proc/[pid]/status，/proc/[pid]/statm等等。什么RSS，RES，DATA，到底哪个才是真正的进程使用内存量？</p><p>有没有简单的手段直接就能知识一个进程的内存占用？很遗憾地说，没有。因为内存的使用，本来就不简单。</p><p>但是我们可以找到相对简单的方式。</p><h2 id="进程的内存分布"><a href="#进程的内存分布" class="headerlink" title="进程的内存分布"></a>进程的内存分布</h2><p>我们要先从进程的内存分布说起。Linux下，一个进程的内存分布如下：</p><p><img src="https://xs-upload.oss-cn-hangzhou.aliyuncs.com/img/Memory-Layout.gif" alt="nginx初始化页"></p><p>从低到高，分别包括：</p><ol><li>文本段，也叫代码段，是对象文件或内存中程序的一部分，其中包含可执行指令。通常代码段是共享的，对于经常执行的程序，只有一个副本需要存储在内存中，代码段是只读的，以防止程序以外修改指令。</li><li>初始化的数据段，是程序的虚拟地址空间的一部分，它包含有程序员初始化的全局变量和静态变量，可以进一步划分为只读区域和读写区域。例如，C中的char=“hello world”的全局字符串，以及main(例如全局)之外的int debug=1这样的C语句。</li><li>未初始化的数据段，通常称为bss段，这个段的数据在程序开始之前有内核初始化为0，包含所有初始化为0和没有显示初始化的全局变量和静态变量，</li><li>堆，堆是动态内存分配通常发生的部分。堆是由程序员自己分配的（malloc kmalloc等）。堆区域由所有共享库和进程中动态加载的模块共享。</li><li>栈，存放临时变量，以及每次调用函数时调用栈。每当调用一个函数时，返回到的地址和关于调用者环境的某些信息的地址，比如一些机器寄存器，就会被保存在栈中。然后，新调用的函数在栈上分配空间，用于自动和临时变量。</li></ol><p>要评估一个进程的内存占用，就是要把以上几个段的内存占用一一加起来。</p><h2 id="Linux环境下内存信息的几个来源"><a href="#Linux环境下内存信息的几个来源" class="headerlink" title="Linux环境下内存信息的几个来源"></a>Linux环境下内存信息的几个来源</h2><h3 id="proc-pid-status"><a href="#proc-pid-status" class="headerlink" title="/proc/[pid]/status"></a>/proc/[pid]/status</h3><p>此文件包含了有关内存使用情况的重要信息，以Vm为前缀。</p><ul><li>VmPeak / VmSize：最大/当前进程正在占用的内存总大小。听起来不错，但实际上，这并不是一个好的评估内存的数据的办法。因为它包含了 1）申请但实际上未使用的内存。（malloc一段地址空间，但不使用它） 2）共享库使用的代码段地址空间，会被多个进程的VmSize同时统计。即存在重复统计的问题。</li><li>VmHWM / VmRss：最大时/当前应用程序正在使用的物理内存的大小。没有被交换到swap的内存。是评估进程内存使用量的重要依据。</li><li>VmData：包含initialized data+bss+heap。通常不准确，原因是heap的大小不准确。系统常常出于优化性能的考虑，多申请栈空间。</li><li>VmExe：代码段中不包含lib的部分，即进程可执行文件的部分</li><li>VmLib： 代码段中lib的部分。</li></ul><h3 id="proc-pid-smap"><a href="#proc-pid-smap" class="headerlink" title="/proc/[pid]/smap"></a>/proc/[pid]/smap</h3><p>这个文件反应了运行时的进程的在内存中的完整分布。这是一张完整的清单。通过它可以看到对应进程所关联的所有的内存信息（包含共享的，和私有的）</p><p>smap示例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">7fc4d49df000-7fc4d49e1000</span> <span class="string">rw-p</span> <span class="string">001eb000</span> <span class="number">08</span><span class="string">:01</span> <span class="number">2102913</span>                    <span class="string">/lib/x86_64-linux-gnu/libc-2.27.so</span></span><br><span class="line"><span class="attr">Size:</span>                  <span class="number">8</span> <span class="string">kB</span></span><br><span class="line"><span class="attr">KernelPageSize:</span>        <span class="number">4</span> <span class="string">kB</span></span><br><span class="line"><span class="attr">MMUPageSize:</span>           <span class="number">4</span> <span class="string">kB</span></span><br><span class="line"><span class="attr">Rss:</span>                   <span class="number">0</span> <span class="string">kB</span></span><br><span class="line"><span class="attr">Pss:</span>                   <span class="number">0</span> <span class="string">kB</span></span><br><span class="line"><span class="attr">Shared_Clean:</span>          <span class="number">0</span> <span class="string">kB</span></span><br><span class="line"><span class="attr">Shared_Dirty:</span>          <span class="number">0</span> <span class="string">kB</span></span><br><span class="line"><span class="attr">Private_Clean:</span>         <span class="number">0</span> <span class="string">kB</span></span><br><span class="line"><span class="attr">Private_Dirty:</span>         <span class="number">0</span> <span class="string">kB</span></span><br><span class="line"><span class="attr">Referenced:</span>            <span class="number">0</span> <span class="string">kB</span></span><br><span class="line"><span class="attr">Anonymous:</span>             <span class="number">0</span> <span class="string">kB</span></span><br><span class="line"><span class="attr">LazyFree:</span>              <span class="number">0</span> <span class="string">kB</span></span><br><span class="line"><span class="attr">AnonHugePages:</span>         <span class="number">0</span> <span class="string">kB</span></span><br><span class="line"><span class="attr">ShmemPmdMapped:</span>        <span class="number">0</span> <span class="string">kB</span></span><br><span class="line"><span class="attr">Shared_Hugetlb:</span>        <span class="number">0</span> <span class="string">kB</span></span><br><span class="line"><span class="attr">Private_Hugetlb:</span>       <span class="number">0</span> <span class="string">kB</span></span><br><span class="line"><span class="attr">Swap:</span>                  <span class="number">8</span> <span class="string">kB</span></span><br><span class="line"><span class="attr">SwapPss:</span>               <span class="number">8</span> <span class="string">kB</span></span><br><span class="line"><span class="attr">Locked:</span>                <span class="number">0</span> <span class="string">kB</span></span><br><span class="line"><span class="attr">THPeligible:</span>        <span class="number">0</span></span><br></pre></td></tr></table></figure><p>几个关键字段：</p><ul><li>Rss：是进程的物理内存占用，包括进程本身和所有链接库，RSS = private + share</li><li>Pss：链接库的共享内存平摊计算后的使用内存，（比如一个动态库有5个人引用，则将其代码段和共享内存除于5），PSS = private + share / share_num</li><li>Shared_Clean：和其他进程共享的未改写页面 </li><li>Shared_Dirty：和其他进程共享的已改写页面</li><li>Private_Clean：未改写的私有页面页面 </li><li>Private_Dirty：已改写的私有页面页面</li></ul><p>其中：<br>Pss这个数据一般能够比较准确反映一个进程内部占用的内存，在内存优化的时候使用这个作为参考值比较合理，进程的物理内存占用就是smaps中所有的Pss的相加（链接的动态库的也要统计进去）。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>/proc/[pid]/status中，VmSize 因包含重复统计和未实际使用的内存，存在夸大的情况。VmHWM / VmRss 是相对理想的内存评估依据。</li><li>想要得到确定的内存使用量，将/proc/[pid]/smap中的所有Pss累加起来，是很好的解决方案。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 内存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>打蚊子与找bug</title>
      <link href="/2020/05/04/mosquito/"/>
      <url>/2020/05/04/mosquito/</url>
      
        <content type="html"><![CDATA[<p>昨晚和蚊子斗争了一晚上，斗争到睡不着。得出感悟，以下：</p><table><thead><tr><th>打蚊子的一晚上</th><th>找bug的一晚上</th></tr></thead><tbody><tr><td>一关灯蚊子就出来嗡嗡嗡，但是开灯手握电蚊拍，它就不见踪影。</td><td>一上生产环境bug就出现，但是打开调试开关，它就不复现。</td></tr><tr><td>好不容易打死一只，另一只又出来嗡嗡嗡，永远不知道房子里一共有多少只蚊子。</td><td>好不容易修复一个bug，又有别的bug出现，永远不知道程序里到底有多少bug。</td></tr><tr><td>不打死蚊子，撑起蚊帐，让蚊子不影响睡眠。</td><td>搞不定bug，引入规避手段，让bug不影响程序的核心功能。继续运行</td></tr></tbody></table><p>结论：打蚊子与找bug真是一模一样。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 日记 </tag>
            
            <tag> 程序人生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux cache参数调优</title>
      <link href="/2020/04/25/vm-cache/"/>
      <url>/2020/04/25/vm-cache/</url>
      
        <content type="html"><![CDATA[<p>缓存机制（cache）是保证Linux环境下对硬盘/flash操作效率的有效方式。cache建立在内存中，它缓存了硬盘/flash的数据，当脏数据到达一定水限时，再异步地将数据刷入硬盘。这可以加速进程的文件系统访问操作。但是也有风险，当数据未写入硬盘前设备重启，存在数据丢失的风险。</p><p>如果缓存相关参数设置得不好，对系统的运行反而会有不良的影响。如果cache过大，当需要把cache中的巨量数据刷入硬盘时，会让系统显得卡顿，甚至无法调度线程。</p><p>Linux提供的接口，以支持修改cache容量。</p><h2 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h2><h3 id="cache中脏数据相关参数"><a href="#cache中脏数据相关参数" class="headerlink" title="cache中脏数据相关参数"></a>cache中脏数据相关参数</h3><p><code>sysctl -a | grep dirty</code>可以看到一组相关的内核参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ sysctl -a | grep dirty</span><br><span class="line">vm.dirty_background_bytes = 0</span><br><span class="line">vm.dirty_background_ratio = 5</span><br><span class="line">vm.dirty_bytes = 0</span><br><span class="line">vm.dirty_expire_centisecs = 600</span><br><span class="line">vm.dirty_ratio = 10</span><br><span class="line">vm.dirty_writeback_centisecs = 100</span><br></pre></td></tr></table></figure><ul><li><strong>vm.dirty_background_bytes</strong>：脏数据量达到此门限后，系统会开始把脏数据写入外存。此时脏数据可能仍然继续写入内存。</li><li><strong>vm.dirty_ratio</strong>：脏数据量达到此门限后，系统会阻塞式地将脏数据写入外存，新的数据将被阻塞，无法写入cache。</li><li><strong>vm.dirty_background_bytes</strong>与<strong>vm.dirty_bytes</strong>：与vm.dirty_background_bytes/vm.dirty_ratio类似，差异仅仅是门限的计数单位，不是内存总量的百分比，而是bytes。注意_ratio与_bytes，有且仅有一个组能生效，如果一组被设置了非0值，另一组就应该被置0。</li><li><strong>vm.dirty_writeback_centisecs</strong>：表示间隔多长时间，系统去检查一次cache中的数据量是否超过门限值，以百分之一秒为单位。</li><li><strong>vm.dirty_expire_centisecs</strong>：表示数据在cache中允许被缓存多长时间。以百分之一秒为单位。</li></ul><h3 id="drop-cache相关参数与操作"><a href="#drop-cache相关参数与操作" class="headerlink" title="drop cache相关参数与操作"></a>drop cache相关参数与操作</h3><p>使用top命令，可以查看当前系统中cache的大小。<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># top</span></span><br><span class="line"><span class="string">top</span> <span class="bullet">-</span> <span class="number">16</span><span class="string">:50:19</span> <span class="string">up</span> <span class="number">4</span> <span class="string">days,</span>  <span class="number">7</span><span class="string">:00,</span> <span class="number">22</span> <span class="string">users,</span>  <span class="attr">load average:</span> <span class="number">25.06</span><span class="string">,</span> <span class="number">24.12</span><span class="string">,</span> <span class="number">23.14</span></span><br><span class="line"><span class="attr">Tasks:</span> <span class="number">493</span> <span class="string">total,</span>   <span class="number">7</span> <span class="string">running,</span> <span class="number">486</span> <span class="string">sleeping,</span>   <span class="number">0</span> <span class="string">stopped,</span>   <span class="number">0</span> <span class="string">zombie</span></span><br><span class="line"><span class="string">%Cpu(s):</span> <span class="number">37.1</span> <span class="string">us,</span> <span class="number">18.9</span> <span class="string">sy,</span>  <span class="number">0.0</span> <span class="string">ni,</span> <span class="number">42.3</span> <span class="string">id,</span>  <span class="number">0.0</span> <span class="string">wa,</span>  <span class="number">0.0</span> <span class="string">hi,</span>  <span class="number">1.7</span> <span class="string">si,</span>  <span class="number">0.0</span> <span class="string">st</span></span><br><span class="line"><span class="attr">KiB Mem :</span> <span class="number">65622752</span> <span class="string">total,</span> <span class="number">30293032</span> <span class="string">free,</span> <span class="number">29879144</span> <span class="string">used,</span>  <span class="number">5450576</span> <span class="string">buff/cache</span></span><br><span class="line"><span class="attr">KiB Swap:</span>        <span class="number">0</span> <span class="string">total,</span>        <span class="number">0</span> <span class="string">free,</span>        <span class="number">0</span> <span class="string">used.</span> <span class="number">31415264</span> <span class="string">avail</span> <span class="string">Mem</span></span><br></pre></td></tr></table></figure></p><p>使用<code>echo 3 &gt; /proc/sys/vm/drop_caches</code>可以手动清理cache。但这并不是一个好主意。cache有它存在的必要。假设一台网页服务器，在drop_cache之后，所有用户访问的数据都将从硬盘中读出，这会显著地影响用户访问网站的体验。</p><p>如果发现cache确实过大，我们应该尽量使用系统提供的参数来调优，不采用主动drop_cache的方式。</p><ul><li><strong>vm.vfs_cache_pressure</strong>：表示系统清理cache的“努力程度”。默认值为100。越大则表示内核会越频繁地回收cache。</li></ul><h2 id="参数建议"><a href="#参数建议" class="headerlink" title="参数建议"></a>参数建议</h2><p>在一台内存为64G，硬盘读写量长期保持在500KB/s的服务器上，在未调优前，经常发生因系统回收cache导致的系统挂起。因此，我们考虑修改参数，提高flush dirty和cache回收的频率，避免脏数据与cache累积过多，一次性回收导致的系统挂起无响应。</p><p>以下参数作参考：<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">vm.dirty_ratio</span>=<span class="number">10</span></span><br><span class="line"><span class="attr">vm.dirty_background_ratio</span>=<span class="number">5</span></span><br><span class="line"><span class="attr">vm.dirty_expire_centisecs</span>=<span class="number">3000</span></span><br><span class="line"><span class="attr">vm.dirty_writeback_centisecs</span>=<span class="number">500</span></span><br><span class="line"><span class="attr">vm.min_free_kbytes</span>=<span class="number">1000000</span></span><br><span class="line"><span class="attr">vm.vfs_cache_pressure</span>=<span class="number">500</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Cache </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker swarm（三） overlay与docker_gwbridge网络详解</title>
      <link href="/2020/03/08/docker-swarm-network/"/>
      <url>/2020/03/08/docker-swarm-network/</url>
      
        <content type="html"><![CDATA[<p>本文通过实验，帮助大家认识docker swarm中的overlay和docker_gwbridge网络。</p><h2 id="实验环境搭建"><a href="#实验环境搭建" class="headerlink" title="实验环境搭建"></a>实验环境搭建</h2><p>先建立两台物理机组成的docker swarm网络（方法可见<a href="https://xiaosong.fun/2020/02/06/docker-swarm-hello" target="_blank" rel="noopener">《docker swarm（一）： 入门，搭建一个简单的swarm集群》</a>）:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker node ls</span><br><span class="line">ID                            HOSTNAME            STATUS              AVAILABILITY        MANAGER STATUS      ENGINE VERSION</span><br><span class="line">43k0p9fnwu9dhsyr0n6utfynn *   ubuntu              Ready               Active              Leader              19.03.5</span><br><span class="line">gorkh8cb5ylb7szzbbrp2sheu     ubuntu-2            Ready               Active                                  19.03.5</span><br></pre></td></tr></table></figure><p>创建一个overlay网络。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create -d overlay --attachable --subnet 10.200.0.0/16 overlay_test</span><br></pre></td></tr></table></figure></p><p>当前建立的docker相关的网络有：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ docker network ls</span><br><span class="line">NETWORK ID          NAME                DRIVER              SCOPE</span><br><span class="line">a473a52d686d        bridge              bridge              <span class="built_in">local</span></span><br><span class="line">5e1880193fbf        docker_gwbridge     bridge              <span class="built_in">local</span></span><br><span class="line">62ba25167374        host                host                <span class="built_in">local</span></span><br><span class="line">jjyg85t5ta3k        ingress             overlay             swarm</span><br><span class="line">d056684646b3        none                null                <span class="built_in">local</span></span><br><span class="line">hxyiridl2b9r        overlay_test        overlay             swarm</span><br></pre></td></tr></table></figure><p>这里关注两个网络：</p><ul><li>overlay_test：overlay网络，实现容器间东西向流量的网络。</li><li>docker_gwbridge: 容器收发南北向报文的网络。</li></ul><h2 id="工具准备"><a href="#工具准备" class="headerlink" title="工具准备"></a>工具准备</h2><p>我们知道，docker是基于namespace，划分了网络空间。这里先准备一段脚本，由于在各个namespece中，执行对应的网络命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">NAMESPACE=<span class="variable">$1</span></span><br><span class="line"><span class="keyword">if</span> [[ -z <span class="variable">$NAMESPACE</span> ]]; <span class="keyword">then</span></span><br><span class="line">    ls -1 /var/run/docker/netns/</span><br><span class="line">    <span class="built_in">exit</span> 0</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">NAMESPACE_FILE=/var/run/docker/netns/<span class="variable">$&#123;NAMESPACE&#125;</span></span><br><span class="line"><span class="keyword">if</span> [[ ! -f <span class="variable">$NAMESPACE_FILE</span> ]]; <span class="keyword">then</span></span><br><span class="line">    NAMESPACE_FILE=$(docker inspect -f <span class="string">"&#123;&#123;.NetworkSettings.SandboxKey&#125;&#125;"</span> <span class="variable">$NAMESPACE</span> 2&gt;/dev/null)</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [[ ! -f <span class="variable">$NAMESPACE_FILE</span> ]]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Cannot open network namespace '<span class="variable">$NAMESPACE</span>': No such file or directory"</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="built_in">shift</span></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$#</span> -lt 1 ]]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"No command specified"</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">nsenter --net=<span class="variable">$&#123;NAMESPACE_FILE&#125;</span> <span class="variable">$@</span></span><br></pre></td></tr></table></figure><p>它可以查看有哪些namespace：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ./docker_netns.sh </span><br><span class="line">1-k2rx924tgr</span><br><span class="line">eab3f856fe9a</span><br><span class="line">ingress_sbox</span><br></pre></td></tr></table></figure><p>还可以在指定的namespace下执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ./docker_netns.sh eab3f856fe9a ip link</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">170: eth0@if171: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1450 qdisc noqueue state UP mode DEFAULT group default </span><br><span class="line">    link/ether 02:42:0a:00:00:54 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">172: eth1@if173: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP mode DEFAULT group default </span><br><span class="line">    link/ether 02:42:ac:12:00:03 brd ff:ff:ff:ff:ff:ff link-netnsid 1</span><br></pre></td></tr></table></figure><p>第二个工具，find_links.sh</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">DOCKER_NETNS_SCRIPT=./docker_netns.sh</span><br><span class="line">IFINDEX=<span class="variable">$1</span></span><br><span class="line"><span class="keyword">if</span> [[ -z <span class="variable">$IFINDEX</span> ]]; <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">for</span> namespace <span class="keyword">in</span> $(<span class="variable">$DOCKER_NETNS_SCRIPT</span>); <span class="keyword">do</span></span><br><span class="line">        <span class="built_in">printf</span> <span class="string">"\e[1;31m%s: \e[0m\n"</span> <span class="variable">$namespace</span></span><br><span class="line">        <span class="variable">$DOCKER_NETNS_SCRIPT</span> <span class="variable">$namespace</span> ip -c -o link</span><br><span class="line">        <span class="built_in">printf</span> <span class="string">"\n"</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">for</span> namespace <span class="keyword">in</span> $(<span class="variable">$DOCKER_NETNS_SCRIPT</span>); <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable">$DOCKER_NETNS_SCRIPT</span> <span class="variable">$namespace</span> ip -c -o link | grep -Pq <span class="string">"^<span class="variable">$IFINDEX</span>: "</span>; <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">printf</span> <span class="string">"\e[1;31m%s: \e[0m\n"</span> <span class="variable">$namespace</span></span><br><span class="line">            <span class="variable">$DOCKER_NETNS_SCRIPT</span> <span class="variable">$namespace</span> ip -c -o link | grep -P <span class="string">"^<span class="variable">$IFINDEX</span>: "</span>;</span><br><span class="line">            <span class="built_in">printf</span> <span class="string">"\n"</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>这个脚本可以根据ifindex查找接口所在的namespace。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ./find_links.sh 60</span><br><span class="line">1-hxyiridl2b: </span><br><span class="line">60: veth1@if59: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1450 qdisc noqueue master br0 state UP mode DEFAULT group default \    link/ether 4a:0a:52:98:84:a7 brd ff:ff:ff:ff:ff:ff link-netnsid 2</span><br></pre></td></tr></table></figure><h2 id="网络结构分析"><a href="#网络结构分析" class="headerlink" title="网络结构分析"></a>网络结构分析</h2><p>以下，我们通过实验，了解一下overlay网络与docker_gwbridge网络。</p><p>我们现在在两个nodes上都创建容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d --name busybox --net overlay_test busybox sleep 36000</span><br></pre></td></tr></table></figure><p>在容器的环境下，查看一下网络连接：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> busybox ip addr</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">59: eth0@if60: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu 1450 qdisc noqueue </span><br><span class="line">    link/ether 02:42:0a:c8:00:02 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 10.200.0.2/16 brd 10.200.255.255 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">61: eth1@if62: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu 1500 qdisc noqueue </span><br><span class="line">    link/ether 02:42:ac:12:00:03 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.18.0.3/16 brd 172.18.255.255 scope global eth1</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure><p>我们发现，除了回环口外，还有两个接口。10.200.0.2/16即是容器busybox在overlay_test网络上的接口的IP地址。172.18.0.3/16是容器busybox在docker_gwbridge网络上的接口的IP地址。</p><p>到目前为止，我们看到的容器网络是这样的。我们只看到了网络地址，还不知道它们间的报文是如何交互的。(192.168.154.2是宿主机的网关)</p><p><img src="https://xs-upload.oss-cn-hangzhou.aliyuncs.com/img/docker_swarm_network/step_0.png" alt="step 0"></p><h3 id="南北向流量"><a href="#南北向流量" class="headerlink" title="南北向流量"></a>南北向流量</h3><p>我们尝试从容器内跟踪访问外部IP的路由</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">exec</span> busybox traceroute baidu.com</span><br><span class="line">traceroute to baidu.com (220.181.38.148), 30 hops max, 46 byte packets</span><br><span class="line"> 1  bogon (172.18.0.1)  0.003 ms  0.004 ms  0.006 ms</span><br><span class="line"> 2  bogon (192.168.154.2)  0.148 ms  0.330 ms  0.175 ms</span><br><span class="line"> ...</span><br></pre></td></tr></table></figure><p>可见，流量经过172.18.0.1，然后访问到宿主机网关上。</p><p>接下来，我们尝试解析出内部网络连接。上面我们已经得知，从容器内部的视角，172.18.0.3所在的接口为：61: eth1@if62。我们可以理解为，此接口的ifindex为61，通过veth连接到ifindex为62的接口上。</p><p>我们查找看看62接口的namespace是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ./find_links.sh 62</span><br></pre></td></tr></table></figure><p>居然没有显示。这就说明62接口是在宿主机的主namespace中的。我们在宿主机上看看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">$ ip addr</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1/128 scope host </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000</span><br><span class="line">    link/ether 00:0c:29:e5:66:45 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 192.168.154.135/24 brd 192.168.154.255 scope global dynamic noprefixroute ens33</span><br><span class="line">       valid_lft 1502sec preferred_lft 1502sec</span><br><span class="line">    inet6 fe80::f378:1d3:6cde:69bb/64 scope link noprefixroute </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">3: docker_gwbridge: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default </span><br><span class="line">    link/ether 02:42:50:e9:2d:e1 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.18.0.1/16 brd 172.18.255.255 scope global docker_gwbridge</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::42:50ff:fee9:2de1/64 scope link </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">4: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN group default </span><br><span class="line">    link/ether 02:42:5d:<span class="built_in">cd</span>:c3:16 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">23: veth6ee82c3@if22: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master docker_gwbridge state UP group default </span><br><span class="line">    link/ether 4a:71:4d:f7:0e:4e brd ff:ff:ff:ff:ff:ff link-netnsid 1</span><br><span class="line">    inet6 fe80::4871:4dff:fef7:e4e/64 scope link </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">62: veth0204500@if61: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master docker_gwbridge state UP group default </span><br><span class="line">    link/ether 9e:d6:10:49:8e:42 brd ff:ff:ff:ff:ff:ff link-netnsid 4</span><br><span class="line">    inet6 fe80::9cd6:10ff:fe49:8e42/64 scope link </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure><p>可见，62接口的master是docker_gwbridge。也就是说，62接口被桥接到docker_gwbridge中。</p><p>南北向流量在经过宿主机出口时，还做了NAT转换</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo iptables-save -t nat  | grep -- <span class="string">'-A POSTROUTING'</span></span><br><span class="line">-A POSTROUTING -o docker_gwbridge -m addrtype --src-type LOCAL -j MASQUERADE</span><br><span class="line">-A POSTROUTING -s 172.17.0.0/16 ! -o docker0 -j MASQUERADE</span><br><span class="line">-A POSTROUTING -s 172.18.0.0/16 ! -o docker_gwbridge -j MASQUERAD</span><br></pre></td></tr></table></figure><p>于是，南北向的流量走向就很清晰了。我们的网络拓扑可以更新为：</p><p><img src="https://xs-upload.oss-cn-hangzhou.aliyuncs.com/img/docker_swarm_network/step_1.png" alt="step 1"></p><h3 id="东西向流量"><a href="#东西向流量" class="headerlink" title="东西向流量"></a>东西向流量</h3><p>东西向流量即容器与容器间的流量。我们先测试一下容器间的连通性。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">exec</span> busybox ping 10.200.0.2</span><br><span class="line">PING 10.200.0.2 (10.200.0.2): 56 data bytes</span><br><span class="line">64 bytes from 10.200.0.2: seq=0 ttl=64 time=41.177 ms</span><br><span class="line">64 bytes from 10.200.0.2: seq=1 ttl=64 time=1.181 ms</span><br><span class="line">64 bytes from 10.200.0.2: seq=2 ttl=64 time=1.110 ms</span><br></pre></td></tr></table></figure><p>接下来探索这个流量是怎么走的。我们再看一下容器中的网络配置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">exec</span> busybox ip addr</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">59: eth0@if60: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu 1450 qdisc noqueue </span><br><span class="line">    link/ether 02:42:0a:c8:00:02 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 10.200.0.2/16 brd 10.200.255.255 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">61: eth1@if62: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu 1500 qdisc noqueue </span><br><span class="line">    link/ether 02:42:ac:12:00:03 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.18.0.3/16 brd 172.18.255.255 scope global eth1</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure><p>10.200.0.2所在的接口为，59: eth0@if60。即本接口ifindex为59，连接到ifindex为60的接口上。我们查询一下60接口所在的namespaec。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ./find_links.sh 60</span><br><span class="line">1-hxyiridl2b: </span><br><span class="line">60: veth1@if59: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1450 qdisc noqueue master br0 state UP mode DEFAULT group default \    link/ether 4a:0a:52:98:84:a7 brd ff:ff:ff:ff:ff:ff link-netnsid 2</span><br></pre></td></tr></table></figure><p>可见60接口处于1-hxyiridl2b这一namespace中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ./docker_netns.sh 1-hxyiridl2b ip addr</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: br0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1450 qdisc noqueue state UP group default </span><br><span class="line">    link/ether 0e:2d:34:e6:eb:b7 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 10.200.0.1/16 brd 10.200.255.255 scope global br0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">56: vxlan0@if56: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1450 qdisc noqueue master br0 state UNKNOWN group default </span><br><span class="line">    link/ether 0e:2d:34:e6:eb:b7 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">58: veth0@if57: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1450 qdisc noqueue master br0 state UP group default </span><br><span class="line">    link/ether ea:c1:db:d4:b1:83 brd ff:ff:ff:ff:ff:ff link-netnsid 1</span><br><span class="line">60: veth1@if59: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1450 qdisc noqueue master br0 state UP group default </span><br><span class="line">    link/ether 4a:0a:52:98:84:a7 brd ff:ff:ff:ff:ff:ff link-netnsid 2</span><br></pre></td></tr></table></figure><p>在这个namespace中，有一个vxlan出口。docker overlsy就是通过overlay隧道与其它容器通信的。</p><p>两个容器虽然是通过vxlan隧道通信，但容器内部却不感知。它们只能看到两个容器处于同一个二层网络中。由vxlan接口将二层报文封装在UDP报文的payload中，发到对端，再由对端的vxlan接口解封装。</p><p>我们查看一下namespace 1-hxyiridl2b中的arp地址表：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ./docker_netns.sh 1-hxyiridl2b ip neigh</span><br><span class="line">10.200.0.5 dev vxlan0 lladdr 02:42:0a:c8:00:05 PERMANENT</span><br><span class="line">10.200.0.4 dev vxlan0 lladdr 02:42:0a:c8:00:04 PERMANENT</span><br></pre></td></tr></table></figure><p>我们可以看到，远端node中的容器IP 10.200.0.4，有体现在本端的arp地址表中。即是通过查找此表，得到对端的二层地址。</p><p>我们再来看看，vxlan报文的出口在哪里：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ./docker_netns.sh 1-hxyiridl2b bridge fdb</span><br><span class="line">...</span><br><span class="line">02:42:0a:c8:00:05 dev vxlan0 dst 192.168.154.136 link-netnsid 0 self permanent</span><br><span class="line">02:42:0a:c8:00:04 dev vxlan0 dst 192.168.154.136 link-netnsid 0 self permanent</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这可以理解为VxLAN的VTEP表，即根据MAC地址，查找出VxLAN报文应该封装的外层IP，是192.168.154.136</p><p>我们可以画出东西向流量的完整的拓扑了：</p><p><img src="https://xs-upload.oss-cn-hangzhou.aliyuncs.com/img/docker_swarm_network/step_2.png" alt="step-2"></p>]]></content>
      
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> docker swarm </tag>
            
            <tag> 容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最长情的告白</title>
      <link href="/2020/02/14/v-day/"/>
      <url>/2020/02/14/v-day/</url>
      
        <content type="html"><![CDATA[<h2 id="QQ，情人节快乐"><a href="#QQ，情人节快乐" class="headerlink" title="QQ，情人节快乐"></a>QQ，情人节快乐</h2><p>百年修得同船渡，千年修得滚床单。</p><p>感谢这份千年的缘分，感谢你这些年的陪伴！</p><p>– S</p><p><img src="https://xs-upload.oss-cn-hangzhou.aliyuncs.com/img/mmexport1440934608008.jpg" alt="happy_wedding"></p><h2 id="爱情秘诀"><a href="#爱情秘诀" class="headerlink" title="爱情秘诀"></a>爱情秘诀</h2><p>c = (a != b) ? a : b;<br>where b=me, and a=my wife: when we agree, she follows me; when we disagree, I follow her.</p>]]></content>
      
      
      
        <tags>
            
            <tag> 日记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker swarm（二） Ingress Routing Mesh的理解与应用</title>
      <link href="/2020/02/11/docker-swarm-inggress-routing-mesh/"/>
      <url>/2020/02/11/docker-swarm-inggress-routing-mesh/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Routing Mesh是docker swarm提供的确保service在多节点网络上可用的集群网络机制。其分为两类：</p><ul><li>Internal Routing Mesh</li><li>Ingress Routing Mesh</li></ul><p>本文先介绍Ingress Routing Mesh。它提供以下服务：如果service有绑定发布接口，则此服务可以通过任意Swarm节点的此端口进行访问。并实现负载均衡。</p><h2 id="Ingress-Routing-Mesh实验"><a href="#Ingress-Routing-Mesh实验" class="headerlink" title="Ingress Routing Mesh实验"></a>Ingress Routing Mesh实验</h2><p>首先搭建一个1 manager, 1 worker的docker swarm。详见《docker swarm（一）： 入门，搭建一个简单的swarm集群》。假设环境如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker node ls</span><br><span class="line">ID                            HOSTNAME            STATUS              AVAILABILITY        MANAGER STATUS      ENGINE VERSION</span><br><span class="line">eak5lww1jjhgwbdm0b97dh8gd *   ubuntu              Ready               Active              Leader              19.03.5</span><br><span class="line">y34vyxwzlumiyzr67sksi44gh     ubuntu-2            Ready               Active                                  19.03.5</span><br></pre></td></tr></table></figure><p>我们使用nginx来做实验，下载nginx的image。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image pull nginx</span><br></pre></td></tr></table></figure><p>创建一个包含两个task的service。–publish定义了docker swarm对外提供服务的端口映射。在下例中，docker swarm对外在8080端口提供服务，中继了nginx container的80端口的报文。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker service create \</span><br><span class="line">  --name my-web \</span><br><span class="line">  --publish published=8080,target=80 \</span><br><span class="line">  --replicas 2 \</span><br><span class="line">  nginx</span><br></pre></td></tr></table></figure><p>检查一下运行状态，在两个节点上分别运行了一个任务。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker service ps my-web</span><br><span class="line">ID                  NAME                IMAGE               NODE                DESIRED STATE       CURRENT STATE            ERROR               PORTS</span><br><span class="line">vqp43b7wqsvu        my-web.1            nginx:latest        ubuntu-2            Running             Running 29 seconds ago                       </span><br><span class="line">a7nbr7chvldm        my-web.2            nginx:latest        ubuntu              Running             Running 24 seconds ago</span><br></pre></td></tr></table></figure><p>访问swarm nodes的8080端口（在本例中是<br><a href="http://192.168.154.135:8080/和" target="_blank" rel="noopener">http://192.168.154.135:8080/和</a><br><a href="http://192.168.154.136:8080/），都可以看到nginx的初始页面。" target="_blank" rel="noopener">http://192.168.154.136:8080/），都可以看到nginx的初始页面。</a></p><p><img src="https://xs-upload.oss-cn-hangzhou.aliyuncs.com/img/nginx_start.png" alt="nginx初始化页"></p><p>下面通过<code>docker service scale</code>把my-web service的任务数改为1。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">spencer@ubuntu:~$ docker service scale my-web=1</span><br><span class="line">my-web scaled to 1</span><br><span class="line">overall progress: 1 out of 1 tasks </span><br><span class="line">1/1: running   [==================================================&gt;] </span><br><span class="line">verify: Service converged </span><br><span class="line">spencer@ubuntu:~$ </span><br><span class="line">spencer@ubuntu:~$ docker service ps my-web</span><br><span class="line">ID                  NAME                IMAGE               NODE                DESIRED STATE       CURRENT STATE            ERROR               PORTS</span><br><span class="line">vqp43b7wqsvu        my-web.1            nginx:latest        ubuntu-2            Running             Running 27 minutes ago</span><br></pre></td></tr></table></figure><p>现在，只在worker节点（192.168.154.136）上运行。</p><p><strong>关键的来了</strong>，虽然现在service仅在worker节点上运行，但我们访问manager和worker节点的8080端口，都能成功访问nginx。</p><p><img src="https://xs-upload.oss-cn-hangzhou.aliyuncs.com/img/nginx_start_2.png" alt="nginx初始化页"></p><h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><p>Docker Swarm内置一个负载均衡器（Balancer），它会监听任意一个节点上的published端口，将端口上的请求中继到容器中。</p><p>实际访问的容器，不一定与用户访问的IP属于同一节点，可能在另一个节点上。</p><p><img src="https://xs-upload.oss-cn-hangzhou.aliyuncs.com/img/ingress-routing-mesh.png" alt="Ingress Routing Mesh"></p><p>在node与node之间，docker swarm建立<a href="https://docs.docker.com/network/overlay/" target="_blank" rel="noopener">overlay网络</a>（名字为ingress），用于容器与容器之间的通信。</p><p>Routing Mesh就是基于ingress overlay网络，实现的节点间的报文转发。</p>]]></content>
      
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> docker swarm </tag>
            
            <tag> 容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker swarm（一） 入门</title>
      <link href="/2020/02/06/docker-swarm-hello/"/>
      <url>/2020/02/06/docker-swarm-hello/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Docker Swarm是容器的集群管理工具。它的主要特性：</p><ul><li>集成于Docker Engine的集群管理工具。</li><li>分布式设计。从一个image生成整个集群。一个docker swarm下的不同node，可以分布于同一，或不同的物理设备上。</li><li>灵活调度。按需启动或关闭容器。</li><li>高可用性。支持监控容器状态，如果容器崩溃，可以自动重启容器。</li><li>支持多样的网络配置。支持overlay、macvlan、bridge、host等网络形式。</li><li>服务发现。</li><li>负载均衡。</li><li>加密传输。默认基于TLS实现容器间的交互，实现加密传输。</li><li>升级回退。支持动态升级容器，如果升级后的容器运行不正常，可自动回退到上一版本。</li></ul><h2 id="主要概念"><a href="#主要概念" class="headerlink" title="主要概念"></a>主要概念</h2><h3 id="node（节点）"><a href="#node（节点）" class="headerlink" title="node（节点）"></a>node（节点）</h3><p>每个docker node都是docker engine的实例（可以理解成，每个docker node即是安装了docker环境的PC），可分为manager和worker两类。</p><ul><li>manager node：<ul><li>给worker nodes分配任务（task）。</li><li>识别worker nodes的状态，调度容器。</li></ul></li><li>worker node<ul><li>执行manager mode分配的任务（task）。</li></ul></li></ul><h3 id="service（服务）与task（任务）"><a href="#service（服务）与task（任务）" class="headerlink" title="service（服务）与task（任务）"></a>service（服务）与task（任务）</h3><p>Docker Swarm通过一个YAML格式的文件，定义了生产环境（in production）中的Docker container行为。此文件包含对services定义、运行、扩容。</p><p>service可以理解为是”containers in production”。它是一个swarm系统中最关键的定义。<br>一个service只能运行一个image，但是可以运行出同一个image的多个containers。</p><p>一个task是swarm调度的最小单位，它运行于manager或worker nodes上。它即对应service中的一个container实例。它包含：</p><ul><li>一个container</li><li>container启动后运行的指令</li></ul><h2 id="搭建一个Docker-Swarm"><a href="#搭建一个Docker-Swarm" class="headerlink" title="搭建一个Docker Swarm"></a>搭建一个Docker Swarm</h2><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>准备两个虚拟机，一个作为manager，一个作为worker。两个虚拟机间能ping通。并且要求以下端口开放访问：2377，2946。</p><h3 id="创建Swarm"><a href="#创建Swarm" class="headerlink" title="创建Swarm"></a>创建Swarm</h3><p>在manager设备上，创建swarm，同时配置一下manager的ip。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ docker swarm init --advertise-addr 192.168.154.135</span><br><span class="line">Swarm initialized: current node (78ayx9kk6n3qr4gcn05nmuvzg) is now a manager.</span><br><span class="line"></span><br><span class="line">To add a worker to this swarm, run the following <span class="built_in">command</span>:</span><br><span class="line"></span><br><span class="line">    docker swarm join --token SWMTKN-1-523lnlcl8xbol5hmg4aab6ur2g2flmdx5zxb31qzj8r8ty0mbo-bhfp0yf7er2vysftf753s3rz5 192.168.154.135:2377</span><br><span class="line"></span><br><span class="line">To add a manager to this swarm, run <span class="string">'docker swarm join-token manager'</span> and follow the instructions.</span><br></pre></td></tr></table></figure><p>通过<code>docker info</code>确认一下swarm已经创建。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ docker info</span><br><span class="line">Client:</span><br><span class="line"> Debug Mode: <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">Server:</span><br><span class="line"> Containers: 5</span><br><span class="line">  Running: 0</span><br><span class="line">  Paused: 0</span><br><span class="line">  Stopped: 5</span><br><span class="line">...</span><br><span class="line"> Swarm: active</span><br><span class="line">  NodeID: 78ayx9kk6n3qr4gcn05nmuvzg</span><br><span class="line">  Is Manager: <span class="literal">true</span></span><br><span class="line">  ClusterID: ommhsz8xug6ltvauyusfn3vsp</span><br><span class="line">  Managers: 1</span><br><span class="line">  Nodes: 1</span><br><span class="line">  Default Address Pool: 10.0.0.0/8  </span><br><span class="line">  SubnetSize: 24</span><br><span class="line">  Data Path Port: 4789</span><br><span class="line">  Orchestration:</span><br><span class="line">   Task History Retention Limit: 5</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>通过<code>docker node ls</code>确认docker node信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker node ls</span><br><span class="line">ID                            HOSTNAME            STATUS              AVAILABILITY        MANAGER STATUS      ENGINE VERSION</span><br><span class="line">78ayx9kk6n3qr4gcn05nmuvzg *   ubuntu              Ready               Active              Leader              19.03.5</span><br></pre></td></tr></table></figure><h3 id="把worker-nodes加入swarm"><a href="#把worker-nodes加入swarm" class="headerlink" title="把worker nodes加入swarm"></a>把worker nodes加入swarm</h3><p>在上一步创建swarm时，docker提示了加入此swarm应执行的命令。在worker node上执行这些命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$  docker swarm join --token SWMTKN-1-523lnlcl8xbol5hmg4aab6ur2g2flmdx5zxb31qzj8r8ty0mbo-bhfp0yf7er2vysftf753s3rz5 192.168.154.135:2377</span><br><span class="line">This node joined a swarm as a worker.</span><br></pre></td></tr></table></figure><p>如果你没有记录下这个加入swarm的命令，可以在manager node上执行<code>docker swarm join-token worker</code>以重新获取命令。</p><p>再回到manager节点上，查看当前swarm的成员。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker node ls</span><br><span class="line">ID                            HOSTNAME            STATUS              AVAILABILITY        MANAGER STATUS      ENGINE VERSION</span><br><span class="line">78ayx9kk6n3qr4gcn05nmuvzg *   ubuntu              Ready               Active              Leader              19.03.5</span><br><span class="line">lugs1vyy3o6z3dvnpytkxf6yi     ubuntu              Ready               Active                                  19.03.5</span><br></pre></td></tr></table></figure><h3 id="创建并部署一个service"><a href="#创建并部署一个service" class="headerlink" title="创建并部署一个service"></a>创建并部署一个service</h3><p>在manager节点上，创建一个service。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker service create --replicas 1 --name helloworld alpine ping docker.com</span><br></pre></td></tr></table></figure><p>参数解释：</p><ul><li>–replicas：service运行的实例个数</li><li>–name: 命名service为helloword</li><li>alpine ping docker.com: 定义此service为，在<br>Alpine Linux容器中，执行ping docker.com</li></ul><p><code>docker service ls</code>确认一下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker service ls</span><br><span class="line">ID                  NAME                MODE                REPLICAS            IMAGE               PORTS</span><br><span class="line">uyxa5ye0061k        helloworld          replicated          1/1                 alpine:latest</span><br></pre></td></tr></table></figure><p>在执行了docker service create之后，此service即是已经被拆解成task执行了。通过以下命令可以查看它的执行状态。这里不具体展开了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker service inspect --pretty &lt;SERVICE-ID&gt;</span><br><span class="line">docker service ps &lt;SERVICE-ID&gt;</span><br></pre></td></tr></table></figure><p><code>docker ps</code>可以查看在当前node上执行的task。此service当前在manager node上执行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">a1f880ea0a72        alpine:latest       <span class="string">"ping docker.com"</span>   16 minutes ago      Up 15 minutes                           helloworld.1.crxx3hwti4wmj5p6zyqe8yi03</span><br></pre></td></tr></table></figure><h3 id="service缩容与扩容"><a href="#service缩容与扩容" class="headerlink" title="service缩容与扩容"></a>service缩容与扩容</h3><p><code>docker service scale</code>可以修改一个serivce衍生出的副本数量，也就是task数量。通过以下命令将helloworld扩容到5个task。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ docker service scale helloworld=5</span><br><span class="line">helloworld scaled to 5</span><br><span class="line">overall progress: 5 out of 5 tasks </span><br><span class="line">1/5: running   [==================================================&gt;] </span><br><span class="line">2/5: running   [==================================================&gt;] </span><br><span class="line">3/5: running   [==================================================&gt;] </span><br><span class="line">4/5: running   [==================================================&gt;] </span><br><span class="line">5/5: running   [==================================================&gt;] </span><br><span class="line">verify: Service converged</span><br></pre></td></tr></table></figure><p>查看service在各nodes上的运行情况</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ docker service ps helloworld</span><br><span class="line">ID                  NAME                IMAGE               NODE                DESIRED STATE       CURRENT STATE                ERROR               PORTS</span><br><span class="line">crxx3hwti4wm        helloworld.1        alpine:latest       ubuntu              Running             Running 55 minutes ago                           </span><br><span class="line">1kej5h5qmkvt        helloworld.2        alpine:latest       ubuntu-2            Running             Running about a minute ago                       </span><br><span class="line">u7i09cvrv7sj        helloworld.3        alpine:latest       ubuntu-2            Running             Running about a minute ago                       </span><br><span class="line">glipqhq70jo7         \_ helloworld.3    alpine:latest       ubuntu-2            Shutdown            Shutdown 8 minutes ago                           </span><br><span class="line">x9qkewnqf2fa        helloworld.4        alpine:latest       ubuntu              Running             Running about a minute ago                       </span><br><span class="line">vwkke0hvmxk8         \_ helloworld.4    alpine:latest       ubuntu-2            Shutdown            Shutdown 8 minutes ago                           </span><br><span class="line">dsyijxuant14        helloworld.5        alpine:latest       ubuntu-2            Running             Running about a minute ago                       </span><br><span class="line">ku0o7qg243tl         \_ helloworld.5    alpine:latest       ubuntu-2            Shutdown            Shutdown 8 minutes ago</span><br></pre></td></tr></table></figure><h3 id="删除service"><a href="#删除service" class="headerlink" title="删除service"></a>删除service</h3><p>执行<code>docker service rm</code>删除service。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker service rm helloworld</span><br><span class="line">helloworld</span><br></pre></td></tr></table></figure><p>若干秒后，此service衍生出的task也都停止运行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker service ps helloworld</span><br><span class="line">no such service: helloworld</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> docker swarm </tag>
            
            <tag> 容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用docker打包一个demo image</title>
      <link href="/2020/01/24/docker-hello/"/>
      <url>/2020/01/24/docker-hello/</url>
      
        <content type="html"><![CDATA[<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>用docker打包一个image，这个image的容器实现打包输出”hello docker”</p><h2 id="打包过程"><a href="#打包过程" class="headerlink" title="打包过程"></a>打包过程</h2><h3 id="搜索基线"><a href="#搜索基线" class="headerlink" title="搜索基线"></a>搜索基线</h3><p>我们计划使用echo命令打印，echo命令基于bash。因此，我们先搜索看看是否有bash相关的image。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">~$ sudo docker search bash</span><br><span class="line">NAME                           DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED</span><br><span class="line">bash                           Bash is the GNU Project<span class="string">'s Bourne Again SHell    232                 [OK]                </span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure><p>可以看到官方的bash image。因此我们可以基于此image来打包生成我们自己的image。</p><h3 id="Dockerfile编写"><a href="#Dockerfile编写" class="headerlink" title="Dockerfile编写"></a>Dockerfile编写</h3><p>创建一个目录hello_docker，在下面创建子目录app，Dockerfile，和脚本hello.sh</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spencer@ubuntu:~/my_docker/hello_docker$ tree .</span><br><span class="line">.</span><br><span class="line">├── app</span><br><span class="line">├── Dockerfile</span><br><span class="line">└── hello.sh</span><br></pre></td></tr></table></figure><p>hello.sh中，就是我们的容器需要执行的指令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"hello docker"</span></span><br></pre></td></tr></table></figure><p>Dockerfile是此步的关键，其内容是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM bash</span><br><span class="line">WORKDIR /app</span><br><span class="line">COPY hello.sh .</span><br><span class="line">CMD [ <span class="string">"bash"</span>, <span class="string">"hello.sh"</span> ]</span><br></pre></td></tr></table></figure><p>解释：</p><ul><li>FROM: 表示当前image基于bash这个官方image来打包</li><li>WORKDIR: 指定容器工作目录，此目录下的内容，才会被打包进容器</li><li>COPY: 将脚本拷贝进工作目录。<strong>注意，此命令的第一个参数是基于宿主机上的当前路径的，也就是Dockerfile所在的目录的相对路径，第二个参数的是基于WORKDIR的相对路径（此例中是app目录）</strong></li><li>CMD: 指定了容器运行起来后，默认要执行的脚本</li></ul><p>可以看出，Dockerfile中，除了CMD指令外，其它指令即是在告诉docker框架，如何一步一步地生成image。</p><h3 id="打包生成容器"><a href="#打包生成容器" class="headerlink" title="打包生成容器"></a>打包生成容器</h3><p>执行以下命令打包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image build -t hello_docker .</span><br></pre></td></tr></table></figure><p>打包完成后，验证一下image已生成</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spencer@ubuntu:~$ docker image ls</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">hello_docker        latest              39dc2cd8ee2b        16 minutes ago      15.2MB</span><br></pre></td></tr></table></figure><h3 id="运行容器"><a href="#运行容器" class="headerlink" title="运行容器"></a>运行容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spencer@ubuntu:~$ docker run hello_docker</span><br><span class="line">hello docker</span><br></pre></td></tr></table></figure><p>搞定！</p><p>Dockerfile是打包image的关键，此例中只用到了简单的几个。如果想进一步了解Dockerfile，请参考<a href="https://docs.docker.com/engine/reference/builder/" target="_blank" rel="noopener">这里</a>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SDN环境下的网络流量识别</title>
      <link href="/2018/08/20/sdn-flow-id/"/>
      <url>/2018/08/20/sdn-flow-id/</url>
      
        <content type="html"><![CDATA[<p>近来作成了一篇论文，发表于<a href="http://ihmsc.zju.edu.cn/" target="_blank" rel="noopener">IHMSC 2018</a>。把神经网络知识应用到网络流量识别中。</p><h1 id="论文主旨"><a href="#论文主旨" class="headerlink" title="论文主旨"></a>论文主旨</h1><p>这篇论文并没有高深的理论研究，可以说是一篇纯应用性质的论文。<br>把SDN与神经网络结合起来，去实现一个网络流量分类系统。<br>SDN与神经网络可以说是一对神仙CP。</p><p><strong>SDN：</strong></p><ul><li>全局性的网络抽象，很方便地收集大量流量特征</li><li>在服务器端可以提供快速的算力支持</li><li>网络可编程</li></ul><p><strong>神经网络：</strong></p><ul><li>需要大量的数据以供训练</li><li>需要大算力</li></ul><p>把这对神仙CP结合起来，SDN负责收集训练流量数据，用于训练神经网络。然后将实时流量数据，输入到训练好的神经网络中，即可得到实时的流量分类数据。</p><p><img src="https://xs-upload.oss-cn-hangzhou.aliyuncs.com/img/sdn_flow_id_0.png" alt="实际的SDN APP在系统中的位置" title="实际的SDN APP在系统中的位置"></p><p><img src="https://xs-upload.oss-cn-hangzhou.aliyuncs.com/img/sdn_flow_id.png" alt="系统结构图" title="系统结构图"></p><h1 id="论文下载"><a href="#论文下载" class="headerlink" title="论文下载"></a>论文下载</h1><p>感兴趣的同学请移步这里下载论文：<a href="https://xs-upload.oss-cn-hangzhou.aliyuncs.com/files/sdn_flow_id_paper.pdf" target="_blank" rel="noopener">下载链接</a>，也欢迎私信交流。</p><h1 id="感恩"><a href="#感恩" class="headerlink" title="感恩"></a>感恩</h1><p>让我比较感恩的是，这个论文研究纯属兴趣，与公司的工作没有太大的关系。但主管仍然对我的研究给予了支持。在一个纯工程团队中，能让我有机会做算法的研究与应用。<br>更让我高兴的一点是：在论文发表了半年之后，这份研究的成果也反哺了公司中一个项目，应用到实际项目中，反哺了公司对我的投资。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 神经网络 </tag>
            
            <tag> AI </tag>
            
            <tag> Openflow </tag>
            
            <tag> SDN </tag>
            
            <tag> 流量识别 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从数据角度解析福州美食</title>
      <link href="/2016/08/21/fz-res/"/>
      <url>/2016/08/21/fz-res/</url>
      
        <content type="html"><![CDATA[<p>作为一个伪吃货（很想吃但有很多忌口，同时又吃不胖），怀着为福州吃货服务的理想，我决定：我来爬爬餐厅。</p><h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><p>Talk is cheap, show me the code. 依照惯例，先贴代码。<br><a href="https://github.com/SmileXie/dianping_crawler" target="_blank" rel="noopener">https://github.com/SmileXie/dianping_crawler</a><br>用python3来收集数据，用MySQL来保存、分析数据。编码中用到了几个Python库：Requests, Beautifulsoup, MySQL Python connector. 数据库用到了MySQL。</p><h1 id="数据样本"><a href="#数据样本" class="headerlink" title="数据样本"></a>数据样本</h1><p>数据样本来源于大家熟知的“大众点评”，收集了其中7740家福州餐厅的数据。<br>其中，包含以下特征之一的数据，我认为是无效的数据，予以剔除:</p><ul><li>点评星级为0</li><li>人均消费大于3000</li></ul><h1 id="统计分析"><a href="#统计分析" class="headerlink" title="统计分析"></a>统计分析</h1><p>每个统计结果之前，我都会把对应的SQL查询语句附上，供较真儿的程序员们分析。</p><h2 id="福州最贵餐厅TOP20"><a href="#福州最贵餐厅TOP20" class="headerlink" title="福州最贵餐厅TOP20"></a>福州最贵餐厅TOP20</h2><p>把所有餐厅按人均消费排序：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select id, name, branch_name, price, category, district from ResTable order by price desc limit 20;</span><br></pre></td></tr></table></figure></p><table><thead><tr><th>餐厅名</th><th>分店名</th><th>人均消费</th><th>分类</th><th>商圈</th></tr></thead><tbody><tr><td>和怀石料理</td><td></td><td>505</td><td>日本料理</td><td>左海/西湖公园</td></tr><tr><td>一德鲍鱼私房菜</td><td></td><td>489</td><td>私房菜</td><td>五四路商务区</td></tr><tr><td>安野牧场烧肉专门店</td><td>二环店</td><td>459</td><td>烧烤</td><td>西禅寺</td></tr><tr><td>荀怀石料理</td><td></td><td>419</td><td>日本料理</td><td>五一广场</td></tr><tr><td>海天盛宴海鲜自助</td><td></td><td>415</td><td>自助餐</td><td>五一广场</td></tr><tr><td>聚春园大酒店</td><td>东街口总店</td><td>411</td><td>福州菜/家常菜</td><td>东街口</td></tr><tr><td>雍和会海鲜姿造</td><td>湖东店</td><td>410</td><td>海鲜</td><td>五四路商务区</td></tr><tr><td>凯宾斯基酒店·云阁扒房</td><td></td><td>405</td><td>西餐</td><td>东二环泰禾</td></tr><tr><td>澜悦海鲜自助餐厅</td><td></td><td>389</td><td>海鲜</td><td>五一广场</td></tr><tr><td>松月自慢料理</td><td></td><td>376</td><td>日本料理</td><td>五四路商务区</td></tr><tr><td>王品牛排</td><td>福州大洋晶典店</td><td>368</td><td>西式正餐</td><td>东街口</td></tr><tr><td>安野牧场烧肉专门店</td><td>信和店</td><td>368</td><td>烧烤</td><td>五四路商务区</td></tr><tr><td>隐家·锅物专门</td><td></td><td>365</td><td>日本料理</td><td>东街口</td></tr><tr><td>王品牛排</td><td>福州泰禾店</td><td>365</td><td>西式正餐</td><td>东二环泰禾</td></tr><tr><td>国惠大酒店</td><td>吴航店</td><td>360</td><td>福州菜/家常菜</td><td>长山湖</td></tr><tr><td>山水大酒店</td><td></td><td>358</td><td>其他中餐</td><td>东街口</td></tr><tr><td>七号院</td><td></td><td>330</td><td>快餐简餐</td><td>左海/西湖公园</td></tr><tr><td>升隆会海鲜旖旎</td><td></td><td>328</td><td>海鲜</td><td>台江万达</td></tr><tr><td>欧斯克生蚝吧</td><td>万科广场</td><td>303</td><td>其他西餐</td><td>宝龙万象</td></tr><tr><td>罗源湾世纪金源大饭店</td><td>餐饮部</td><td>300</td><td>自助餐</td><td>罗源县其他</td></tr></tbody></table><p>“福州最贵餐厅”称号被“和怀石料理”收入囊中，人均消费505元让我等屌丝望而确步。人均消费400+的餐厅有八家。<br>TOP20中，日本料理分类占得最多。左海/西湖公园、五四路商业区、五一广场是TOP20高端消费餐厅较为聚集的商圈。<br>比较尴尬的一点是。大众点评的app中已经有了比较完善的排序功能。在app中已经可以方便地按价格排序得到以上的结果。那感觉……</p><p><img src="https://xs-upload.oss-cn-hangzhou.aliyuncs.com/img/fz_res_bgl.png" alt></p><p>下面我只好剑走偏锋，给大家总结一点点评app上筛选不出的数据。</p><h2 id="福州餐厅价格分布"><a href="#福州餐厅价格分布" class="headerlink" title="福州餐厅价格分布"></a>福州餐厅价格分布</h2><p>假设对福州的餐厅消费按以下规则来分类</p><table><thead><tr><th>分类</th><th>人均消费价格区间 </th></tr></thead><tbody><tr><td>高消费</td><td>&gt;= 200</td></tr><tr><td>中消费</td><td>&gt;= 100 &amp; &lt; 200</td></tr><tr><td>低消费</td><td>&gt;= 30 &amp; &lt; 100</td></tr><tr><td>屌丝消费</td><td>&lt; 30</td></tr></tbody></table><p>考虑到屌丝消费的餐厅，大多数都没有在大众点评记录，或因没有星级而被当成无效记录，统计可能失准。因此下面不对小于30元/人 消费水平的餐厅作统计。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select count(*) from ResTable where price &gt;= 200;</span><br><span class="line">mysql&gt; select count(*) from ResTable where price &lt; 200 and price &gt;= 100;</span><br><span class="line">mysql&gt; select count(*) from ResTable where price &lt; 100 and price &gt;= 30;</span><br></pre></td></tr></table></figure><p><img src="https://xs-upload.oss-cn-hangzhou.aliyuncs.com/img/fz_res_price.png" alt="福州餐厅消费水平"></p><p>从数量上看，中低消费的餐厅还是占据大部分。</p><h2 id="福州的吃货商圈"><a href="#福州的吃货商圈" class="headerlink" title="福州的吃货商圈"></a>福州的吃货商圈</h2><p>统计数据库中各商圈的餐厅数量，如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select district, count(*) from ResTable group by district order by count(*) desc limit 30;</span><br></pre></td></tr></table></figure></p><table><thead><tr><th>商圈</th><th>餐厅数量</th></tr></thead><tbody><tr><td>其他地区</td><td>563</td></tr><tr><td>闽侯县</td><td>516</td></tr><tr><td>连江县其他</td><td>320</td></tr><tr><td>马尾区</td><td>277</td></tr><tr><td>平潭县其他</td><td>254</td></tr><tr><td>宝龙万象</td><td>242</td></tr><tr><td>东街口</td><td>231</td></tr><tr><td>仓山万达</td><td>212</td></tr><tr><td>晋安区</td><td>189</td></tr><tr><td>仓山区</td><td>185</td></tr><tr><td>永泰县其他</td><td>173</td></tr><tr><td>中亭街</td><td>171</td></tr><tr><td>博仕后</td><td>171</td></tr><tr><td>台江区</td><td>168</td></tr><tr><td>福建师大</td><td>166</td></tr><tr><td>五四路商务区</td><td>163</td></tr><tr><td>新西客站</td><td>145</td></tr><tr><td>茶亭世茂</td><td>140</td></tr><tr><td>鼓楼区</td><td>135</td></tr><tr><td>王庄</td><td>134</td></tr><tr><td>鼓山</td><td>130</td></tr><tr><td></td><td>124</td></tr><tr><td>东二环泰禾</td><td>119</td></tr><tr><td>左海/西湖公园</td><td>118</td></tr><tr><td>榕城广场</td><td>115</td></tr><tr><td>罗源县其他</td><td>111</td></tr><tr><td>五一广场</td><td>109</td></tr><tr><td>凤城镇</td><td>107</td></tr><tr><td>成龙步行街</td><td>102</td></tr><tr><td>潭城镇</td><td>98</td></tr></tbody></table><p>以上商圈中，我们剔除掉行政区域的数据（如闽侯县，马尾区，其他地区），因为这些区域下的餐厅，通常不属于任何商圈，于是就被划分到以行政区域命名的区域中。剔除掉以上数据后，福州各大商圈的餐厅数据排序为：</p><table><thead><tr><th>商圈</th><th>餐厅数量 </th></tr></thead><tbody><tr><td>宝龙万象</td><td>242</td></tr><tr><td>东街口</td><td>231</td></tr><tr><td>仓山万达</td><td>212</td></tr><tr><td>博仕后</td><td>171</td></tr><tr><td>中亭街</td><td>171</td></tr><tr><td>福建师大</td><td>166</td></tr><tr><td>五四路商务区</td><td>163</td></tr><tr><td>新西客站</td><td>145</td></tr><tr><td>茶亭世茂</td><td>140</td></tr><tr><td>王庄</td><td>134</td></tr></tbody></table><p>宝龙万象果然是最大的吃货聚集地，老牌商圈东街口排名老二，近几年新兴的商圈仓山万达和博仕后分列三、四位。<br>值得注意的是，吃货商圈top10中，有两个是位于闽侯县。也说明闽侯大学城区块正在逐渐融入市区，有很大的发展潜力。</p><h2 id="福州的高富帅商圈"><a href="#福州的高富帅商圈" class="headerlink" title="福州的高富帅商圈"></a>福州的高富帅商圈</h2><p>上面统计了各大商圈的餐厅的“量”，以下来统计一下“价”。看看了解一下福州各大商圈中，哪个才是“高富帅”商圈。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select district, avg(price) from ResTable where district = 'xxxx' and price &gt; 0;</span><br></pre></td></tr></table></figure></p><p>综合统计上述各大商圈的餐厅的人均消费，如下：</p><p><img src="https://xs-upload.oss-cn-hangzhou.aliyuncs.com/img/fz_res_district.png" alt="福州各大商圈的人均消费"></p><p>五四路商务区是高端白领聚焦地，一举夺下福州最“高富帅”商圈称号。而位于闽侯上街区块的博仕后与新西客站，虽然在餐厅的“量”上挤入了福州top10商圈，但仍难以摆脱低端印象，在人均消费均价上排名垫底。“学生街”所在的福建师大商圈，聚焦了大量的小吃，人均消费也不会太高。</p><h2 id="分店最多的连锁餐厅"><a href="#分店最多的连锁餐厅" class="headerlink" title="分店最多的连锁餐厅"></a>分店最多的连锁餐厅</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select name, count(*) from ResTable where price &gt; 20 group by name order by count(*) desc limit 30;</span><br></pre></td></tr></table></figure><table><thead><tr><th>餐厅名</th><th>分店数量</th></tr></thead><tbody><tr><td>玛格利塔</td><td>40</td></tr><tr><td>德克士</td><td>39</td></tr><tr><td>麦当劳</td><td>38</td></tr><tr><td>桥亭活鱼小镇</td><td>36</td></tr><tr><td>周麻婆</td><td>34</td></tr><tr><td>醉得意</td><td>33</td></tr><tr><td>芝根芝底</td><td>29</td></tr><tr><td>肯德基</td><td>24</td></tr><tr><td>令狐冲窑烤活鱼</td><td>19</td></tr><tr><td>煌上煌</td><td>18</td></tr><tr><td>七恭冒菜</td><td>18</td></tr><tr><td>必胜客</td><td>18</td></tr><tr><td>蹄膀破店</td><td>16</td></tr><tr><td>星巴克</td><td>15</td></tr><tr><td>黄鹤楼</td><td>15</td></tr><tr><td>广芳园老香港茶点</td><td>15</td></tr><tr><td>大丰收鱼庄</td><td>14</td></tr><tr><td>重庆鸡公煲</td><td>13</td></tr><tr><td>天朋手</td><td>12</td></tr><tr><td>神龙冒菜</td><td>11</td></tr><tr><td>盛世经典牛排</td><td>10</td></tr><tr><td>小叫天泡椒活田鸡</td><td>10</td></tr><tr><td>鱼旨寿司</td><td>10</td></tr><tr><td>江记海鲜火锅</td><td>10</td></tr><tr><td>佳客来</td><td>9</td></tr><tr><td>牛太郎烧烤城</td><td>9</td></tr><tr><td>石山水美式餐厅</td><td>8</td></tr><tr><td>必来客</td><td>8</td></tr><tr><td>人人江记海鲜火锅</td><td>8</td></tr><tr><td>大丰收李家</td><td>8</td></tr></tbody></table><p>分店最多的餐厅，统计的时候，加上了人均消费价格大于20的限制。因为低消费的餐厅，在大众点评上没有完整的登记，统计出来的分店数量也有较大的偏差。</p><p>根据上面的统计结果，排名第一的是卖Pizza的玛格利塔。M记与K记在福州竞争了这么多年，从餐厅数量上来看，还是M记占了上风。</p><h2 id="“三九”餐厅"><a href="#“三九”餐厅" class="headerlink" title="“三九”餐厅"></a>“三九”餐厅</h2><p>所谓三九餐厅，是指口味、服务、环境评分都在9.0（包含9.0）之上的餐厅。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select name, branch_name, taste, service, surroundings, price, star from ResTable</span><br><span class="line">    -&gt; where taste &gt;= 9.0 and service &gt;= 9.0 and surroundings &gt;= 9.0 order by price;</span><br></pre></td></tr></table></figure><table><thead><tr><th>餐厅</th><th>分店名</th><th>口味</th><th>服务</th><th>环境</th><th>人均消费</th><th>点评星级</th></tr></thead><tbody><tr><td>陶乡</td><td>仓山爱琴海东百分店</td><td>9.1</td><td>9.1</td><td>9.2</td><td>78</td><td>5.0</td></tr><tr><td>探鱼</td><td>苏宁广场店</td><td>9.0</td><td>9.1</td><td>9.1</td><td>78</td><td>5.0</td></tr><tr><td>百加百炭火烤肉专门店</td><td></td><td>9.1</td><td>9.0</td><td>9.1</td><td>80</td><td>5.0</td></tr><tr><td>陶乡</td><td>群升店</td><td>9.0</td><td>9.1</td><td>9.1</td><td>80</td><td>5.0</td></tr><tr><td>重庆高老九火锅</td><td>大利嘉城店</td><td>9.0</td><td>9.0</td><td>9.0</td><td>98</td><td>5.0</td></tr><tr><td>味蜀吾老火锅</td><td>福州六一路店</td><td>9.0</td><td>9.0</td><td>9.1</td><td>116</td><td>4.5</td></tr><tr><td>揽季锅物会</td><td>水调歌头店</td><td>9.1</td><td>9.2</td><td>9.0</td><td>127</td><td>5.0</td></tr><tr><td>揽季锅物会</td><td>乐都汇店</td><td>9.0</td><td>9.1</td><td>9.0</td><td>143</td><td>5.0</td></tr><tr><td>雍和会海鲜姿造</td><td>三坊七巷店</td><td>9.1</td><td>9.1</td><td>9.1</td><td>220</td><td>5.0</td></tr><tr><td>花潮日料艺食馆</td><td></td><td>9.1</td><td>9.2</td><td>9.3</td><td>300</td><td>5.0</td></tr><tr><td>松月自慢料理</td><td></td><td>9.1</td><td>9.0</td><td>9.3</td><td>376</td><td>5.0</td></tr><tr><td>雍和会海鲜姿造</td><td>湖东店</td><td>9.0</td><td>9.0</td><td>9.1</td><td>410</td><td>4.5</td></tr><tr><td>海天盛宴海鲜自助</td><td></td><td>9.0</td><td>9.1</td><td>9.1</td><td>415</td><td>5.0</td></tr></tbody></table><p>上面是“三九”餐厅，价格按从低到高排序的结果。有五家店的人均消费小于100，便宜未必没好货。</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>再贴一遍源码: <a href="https://github.com/SmileXie/dianping_crawler" target="_blank" rel="noopener">https://github.com/SmileXie/dianping_crawler</a><br>自从老婆看到了那份“福州最贵餐厅TOP20”的榜单后，就立志要把TOP20全吃一遍。不说了，我赚钱去了。。。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
